<#@ assembly name="EnvDTE" #>
<#@ assembly name="System.Core.dll" #>
<#@ assembly name="System.Data" #>
<#@ assembly name="System.Data.Entity.Design" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Configuration" #>
<#@ assembly name="System.Windows.Forms" #>
<#@ import namespace="Microsoft.VisualStudio.TextTemplating" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Data" #>
<#@ import namespace="System.Data.SqlClient" #>
<#@ import namespace="System.Data.Common" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.Globalization" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="System.Configuration" #>
<#@ import namespace="System.Windows.Forms" #>
<#
/*
This code is based on the work of the contributors of Dapper.SimpleCRUD, PetaPoco and Dapper.FastCrud projects.
 -----------------------------------------------------------------------------------------
 This template can read minimal schema information from the following databases:

	* SQL Server
 -----------------------------------------------------------------------------------------
*/

	WriteLine($@"// =============================================================================================");
	WriteLine($@"// This file was automatically generated by the Dapper.FastCRUD T4 Template");
	WriteLine($@"// Do not make changes directly to this file - edit the template configuration instead");
	WriteLine($@"// ");
	WriteLine($@"// The following settings were used to generate this file:");
	WriteLine($@"// ");
	WriteLine($@"//     Provider:                                          {ProviderName}");
	// For security reasons, do not include this information
	//WriteLine("//     Connection String:      `{0}`", RemovePassword(ConnectionString));
	WriteLine($@"//     Views included:                                    {IncludeViews}");
	WriteLine($@"//     Relationships included:                            {IncludeRelationships}");
	WriteLine($@"//     Default database column value generation analysis: {!IgnoreColumnDefaultValues}");
	WriteLine($@"// =============================================================================================");

	// Read schema
	var tables = LoadTables();

    var indentationStep = "    ";
    var currentIndentation = "";
	WriteLine($@"{currentIndentation}namespace {this.Namespace}");
	WriteLine($@"{currentIndentation}{{");
	{
		currentIndentation += indentationStep;

		// start with the namespace includes
		WriteLine($@"{currentIndentation}using System;");
		WriteLine($@"{currentIndentation}using System.ComponentModel.DataAnnotations;");
		WriteLine($@"{currentIndentation}using System.ComponentModel.DataAnnotations.Schema;");
		WriteLine($@"{currentIndentation}using System.Collections.Generic;");

		// now go ahead with the table classes
		foreach (var table in tables)
		{
			// set up the header for the class
			WriteLine($@"{currentIndentation}/// <summary>");
			foreach (var tableDescriptionLine in table.Description)
			{
				WriteLine($@"{currentIndentation}/// {tableDescriptionLine}");
			}
			WriteLine($@"{currentIndentation}/// Represents the '{table.Name}' {(table.IsView?"view":"table")}.");
			WriteLine($@"{currentIndentation}/// </summary>");

			// now go ahead with the class definition
			WriteLine($@"{currentIndentation}[Table(""{table.Name}"")]");
			WriteLine($@"{currentIndentation}public partial class {table.ClassName}");
			WriteLine($@"{currentIndentation}{{");
			{
				currentIndentation += indentationStep;

				// now we'll look at the columns
				var firstProperty = true;
				foreach (var column in table.Columns)
				{
					if (firstProperty)
					{
						firstProperty = false;
					}
					else
					{
						WriteLine("");
					}

					// column header comes first
					WriteLine($@"{currentIndentation}/// <summary>");
					foreach (var columnDescriptionLine in column.Description)
					{
						WriteLine($@"{currentIndentation}/// {columnDescriptionLine}");
					}
					WriteLine($@"{currentIndentation}/// Represents the column '{column.Name}'.");
					WriteLine($@"{currentIndentation}/// </summary>");

					// column attributes
					if (column.IsPK)
					{
						WriteLine($@"{currentIndentation}[Key]");
					}

					if (column.IsAutoIncrement || (column.IsPK && column.HasDefaultValue && column.IsGeneratedUniqueIdentifier))
					{
						WriteLine($@"{currentIndentation}[DatabaseGenerated(DatabaseGeneratedOption.Identity)]");
					}
					else if (column.IsComputed )
					{
						WriteLine($@"{currentIndentation}[DatabaseGenerated(DatabaseGeneratedOption.Computed)]");
					}
					else if (column.HasDefaultValue && !IgnoreColumnDefaultValues)
					{
						WriteLine($@"{currentIndentation}[Dapper.FastCrud.DatabaseGeneratedDefaultValue]");
					}

					if (column.Order != null || column.PropertyName != column.Name)
					{
						Write($@"{currentIndentation}[Column(");
						if (column.PropertyName != column.Name)
						{
							Write($@"""{column.Name}""");
							if (column.Order != null)
							{
								Write($@", ");
							}
						}
						if (column.Order != null)
						{
							Write($@"Order = {column.Order}");
						}
						WriteLine($@")]");
					}

					// is the column part of a child-parent relationship?
					foreach (var childParentRelationshipAttachedToColumn in table
						.ChildParentRelationships
						.Where(rel => rel.ReferencingColumnNames.Contains(column.Name)))
					{
						WriteLine($@"{currentIndentation}[ForeignKey(nameof({childParentRelationshipAttachedToColumn.ReferencingNavigationPropertyName}))]");
					}

					// time for the actual property
					WriteLine($@"{currentIndentation}public virtual {column.PropertyType}{(column.IsNullable?"?":"")} {column.PropertyName} {{ get; set; }}");
				}

				// now it's time for the navigation properties
				foreach (var childParentRelationship in table.ChildParentRelationships)
				{
					if (firstProperty)
					{
						firstProperty = false;
					}
					else
					{
						WriteLine("");
					}

					WriteLine($@"{currentIndentation}/// <summary>");
					WriteLine($@"{currentIndentation}/// Represents the navigation property for the child-parent relationship involving <seealso cref=""{tables[childParentRelationship.ReferencedTableName].ClassName}""/>");
					WriteLine($@"{currentIndentation}/// </summary>");
					WriteLine($@"{currentIndentation}public virtual {tables[childParentRelationship.ReferencedTableName].ClassName} {childParentRelationship.ReferencingNavigationPropertyName} {{ get; set; }}");
				}

				foreach (var parentChildRelationship in table.ParentChildRelationships)
				{
					if (firstProperty)
					{
						firstProperty = false;
					}
					else
					{
						WriteLine("");
					}

					var referencedTable = tables[parentChildRelationship.ReferencedTableName];
					var matchingChildParentRelationship = referencedTable.ChildParentRelationships.Single(childParentRelationship => childParentRelationship.RelationshipName == parentChildRelationship.RelationshipName);

					WriteLine($@"{currentIndentation}/// <summary>");
					WriteLine($@"{currentIndentation}/// Represents the navigation property for the parent-children relationship involving <seealso cref=""{referencedTable.ClassName}""/>");
					WriteLine($@"{currentIndentation}/// </summary>");
					WriteLine($@"{currentIndentation}[InverseProperty(nameof({referencedTable.ClassName}.{matchingChildParentRelationship.ReferencingNavigationPropertyName}))]");
					if (parentChildRelationship.ReferencingNavigationPropertyIsCollection)
					{
						WriteLine($@"{currentIndentation}public virtual IEnumerable<{referencedTable.ClassName}>? {parentChildRelationship.ReferencingNavigationPropertyName} {{ get; set; }}");
					}
					else
					{
						WriteLine($@"{currentIndentation}public virtual {referencedTable.ClassName}? {parentChildRelationship.ReferencingNavigationPropertyName} {{ get; set; }}");
					}
				}

				currentIndentation = currentIndentation.Substring(0, currentIndentation.Length - indentationStep.Length);
			}
			WriteLine($@"{currentIndentation}}}");
			WriteLine("");
		}

		currentIndentation = currentIndentation.Substring(0, currentIndentation.Length - indentationStep.Length);
	}
	WriteLine($@"{currentIndentation}}}");
#>

<#+
// this is a helper block and everything here can be used by the main block above
string ConnectionStringName = "";
string ConfigPath = "";
string Namespace = "";
string InvalidPropertyNamePrefix = "P";
string ClassPrefix = "";
string ClassSuffix = "";
string SchemaName = null;
bool IncludeViews;
bool IncludeRelationships = false;
bool IgnoreColumnDefaultValues = true;
string[] ExcludeTablePrefixes = new string[]{};
int MaxTextLine = 140; // currently only used by the description text

// we'll uppercase all the chars in the name that match the following regex: 
// \p{L} = all letters in unicode
static Regex NameTitleCaseUppercaseRegex = new Regex(@"(?<=(^|[^\p{L}]))\p{L}", RegexOptions.IgnoreCase);

// we'll prefix the name if it starts with the following:
static string[] ReservedFullNames = { "abstract", "event", "new", "struct", "as", "explicit", "null", 
	"switch", "base", "extern", "object", "this", "bool", "false", "operator", "throw", 
	"break", "finally", "out", "true", "byte", "fixed", "override", "try", "case", "float", 
	"params", "typeof", "catch", "for", "private", "uint", "char", "foreach", "protected", 
	"ulong", "checked", "goto", "public", "unchecked", "class", "if", "readonly", "unsafe", 
	"const", "implicit", "ref", "ushort", "continue", "in", "return", "using", "decimal", 
	"int", "sbyte", "virtual", "default", "interface", "sealed", "volatile", "delegate", 
	"internal", "short", "void", "do", "is", "sizeof", "while", "double", "lock", 
	"stackalloc", "else", "long", "static", "enum", "namespace", "string",
	"Equals", "GetHashCode","GetType","ToString","repo","Save","IsNew","Insert","Update",
	"Delete","Exists","SingleOrDefault","Single","First","FirstOrDefault","Fetch","Page","Query"
};

// we'll prefix the name if it starts with the following regex: 
static Regex ReservedStartNameRegex = new Regex(@"^(\d)|(tbl)", RegexOptions.IgnoreCase);

// we'll remove the following instances of regex, no matter where they are in the name:
static Regex InvalidNamePortionRegex = new Regex(@"([\s_]+)|(tbl)", RegexOptions.IgnoreCase);

	static string ToFirstUppercase(string s)
	{
		if (s == null || s.Length == 0)
		{
			return s;
		}

		return char.ToUpper(s[0], CultureInfo.CurrentCulture) + s.Substring(1);
	}

	static string ToTitleCase(string inputString)
	{
		if (string.IsNullOrEmpty(inputString))
		{
			return inputString;
		}

		var outputString = NameTitleCaseUppercaseRegex.Replace(inputString,
		                                                       match =>
		                                                       {
			                                                       return match.Value.ToUpper(CultureInfo.CurrentCulture);
		                                                       });
		return outputString;
	}

	static string Singularize(string word)
	{
		var singularword = System.Data.Entity.Design.PluralizationServices.PluralizationService.CreateService(System.Globalization.CultureInfo.GetCultureInfo("en-us")).Singularize(word);
		return singularword;
	}

	static string Pluralize(string word)
	{
		var pluralWord = System.Data.Entity.Design.PluralizationServices.PluralizationService.CreateService(System.Globalization.CultureInfo.GetCultureInfo("en-us")).Pluralize(word);
		return pluralWord;
	}

	public class Table
	{
		private string _invalidPropertyNamePrefix;
		public List<Column> Columns = new List<Column>();
		public List<Relationship> ParentChildRelationships = new List<Relationship>();
		public List<Relationship> ChildParentRelationships = new List<Relationship>();
		public string Name;
		public string Schema;
		public bool IsView;
		public string ClassName;
		public string SequenceName;
		public bool? Ignore;
		public string[] Description;

		public Table(string invalidPropertyNamePrefix)
		{
			_invalidPropertyNamePrefix = invalidPropertyNamePrefix;
		}

		public Column GetColumn(string columnName)
		{
			var locatedColumns = this.Columns.Where(x => string.Equals(x.Name, columnName, StringComparison.InvariantCultureIgnoreCase)).ToArray();
			if (locatedColumns.Length != 1)
			{
				throw new InvalidOperationException($"Expected to find 1 column named '{columnName}' on the table '{this.Name}' but found {locatedColumns.Length}");
			}
			return locatedColumns[0];
		}

		public Column this[string columnName]
		{
			get
			{
				return GetColumn(columnName);
			}
		}

		public string GetNewValidPropertyName(string newPropNameHint)
		{
			var propName = newPropNameHint;

			// In case of a full reserved name, prepend the whole name
			if (ReservedFullNames.Any(reservedFullName => string.Equals(reservedFullName, propName, StringComparison.CurrentCultureIgnoreCase)))
			{
				if (string.IsNullOrEmpty(_invalidPropertyNamePrefix))
				{
					throw new ArgumentException($"Invalid property name '{propName}' (reserved name). Check the wiki for instructions on how to tweak the template parameters.");
				}
				propName = $"{_invalidPropertyNamePrefix}{ToFirstUppercase(propName)}";
			}

			// before we go with checking the characters, we need to convert it to title case
			propName = ToTitleCase(propName);

			// if they start with something bad, prepend it
			if (ReservedStartNameRegex.Matches(propName).Count > 0)
			{
				propName = $"{_invalidPropertyNamePrefix}{ToFirstUppercase(propName)}";
			}

			// if any of it contains invalid characters, remove them
			propName = InvalidNamePortionRegex.Replace(propName, "");

			// now we need to check with the rest of property names already reserved
			var basePropName = propName;
			var prefixCount = 1;
			while (this.Columns.Select(col => col.PropertyName)
			           .Concat(this.ParentChildRelationships.Select(rel => rel.ReferencingNavigationPropertyName))
			           .Concat(this.ChildParentRelationships.Select(rel => rel.ReferencingNavigationPropertyName))
			           .Concat(new []{this.ClassName})
			           .Contains(propName))
			{
				propName = basePropName + prefixCount.ToString();
				prefixCount++;
			}

			return propName;
		}
	}

	public class Column
	{
		public string Name;
		public string PropertyName;
		public string PropertyType;
		public bool IsPK;
		public bool HasDefaultValue;
		public bool IsNullable;
		public bool IsAutoIncrement;
		public bool IsComputed;
		public bool Ignore;
		public bool IsGeneratedUniqueIdentifier;
		public string[] Description;
		public int? Order; // order is used to match columns that are part of composite keys and also take part in relationships
	}

	public class Relationship
	{
		public string RelationshipName;
		public string[] ReferencingColumnNames;
		public string[] ReferencedColumnNames;
		public string ReferencedTableName;

		public string ReferencingNavigationPropertyName;

		public bool ReferencingNavigationPropertyIsCollection; // this is only used for parent-children relationships
	}

	public class Tables : List<Table>
	{
		public Tables()
		{
		}

		public Tables(IEnumerable<Table> existingTables)
		:base(existingTables)
		{
		}

		public Table GetTable(string tableName)
		{
			var locatedTables = this.Where(x => string.Equals(x.Name, tableName, StringComparison.InvariantCultureIgnoreCase)).ToArray();
			if (locatedTables.Length != 1)
			{
				throw new InvalidOperationException($"Expected to find 1 table named '{tableName}' but found {locatedTables.Length}");
			}
			return locatedTables[0];
		}

		public Table this[string tableName]
		{
			get
			{
				return GetTable(tableName);
			}
		}

		public string GetNewValidClassName(string newClassNameHint)
		{
			var className = newClassNameHint;

			// In case of a full reserved name, prepend the whole name
			if (ReservedFullNames.Any(reservedFullName => string.Equals(reservedFullName, className, StringComparison.CurrentCultureIgnoreCase)))
			{
				// this should not happen and can be fixed by changing the template parameters
				throw new ArgumentException($"Invalid class name '{newClassNameHint}' (reserved word). Check the wiki for instructions on how to tweak the template parameters.");
			}

			// before we go with checking the characters, we need to convert it to title case
			className = ToTitleCase(className);

			// if they start with something bad, remove it
			className = InvalidNamePortionRegex.Replace(className, "");

			if (className == string.Empty)
			{
				throw new ArgumentException($"Invalid table name (empty class names).");
			}

			if (this.Any(table => string.Equals(table.ClassName, className, StringComparison.CurrentCultureIgnoreCase)))
			{
				throw new ArgumentException($"Invalid class name '{newClassNameHint}' (duplicate class names).");
			}

			return className;
		}

	}

	string GetConnectionString(ref string connectionStringName, out string providerName)
	{
		var currentProject = GetCurrentProject();

		providerName = null;

		string result = "";
		ExeConfigurationFileMap configFile = new ExeConfigurationFileMap();
		configFile.ExeConfigFilename = GetConfigPath();

		if (string.IsNullOrEmpty(configFile.ExeConfigFilename))
			throw new ArgumentNullException("The project does not contain App.config or Web.config file.");


		var config = System.Configuration.ConfigurationManager.OpenMappedExeConfiguration(configFile, ConfigurationUserLevel.None);
		var connSection = config.ConnectionStrings;

		//if the connectionString is empty - which is the defauls
		//look for count-1 - this is the last connection string
		//and takes into account AppServices and LocalSqlServer
		if (string.IsNullOrEmpty(connectionStringName))
		{
			if (connSection.ConnectionStrings.Count > 1)
			{
				connectionStringName = connSection.ConnectionStrings[connSection.ConnectionStrings.Count - 1].Name;
				result = connSection.ConnectionStrings[connSection.ConnectionStrings.Count - 1].ConnectionString;
				providerName = connSection.ConnectionStrings[connSection.ConnectionStrings.Count - 1].ProviderName;
			}
		}
		else
		{
			try
			{
				result = connSection.ConnectionStrings[connectionStringName].ConnectionString;
				providerName = connSection.ConnectionStrings[connectionStringName].ProviderName;
			}
			catch(Exception ex)
			{
				var error = ex.Message.Replace("\r\n", "\n").Replace("\n", " ");
				WriteLine("");
				WriteLine("// -----------------------------------------------------------------------------------------");
				WriteLine($"// Failed to locate connection string `{connectionStringName}` - {error}");
				WriteLine("// -----------------------------------------------------------------------------------------");
				WriteLine("");
				this.Error($"Failed to locate connection string `{connectionStringName}` - {error}");
				throw;

				// result = "There is no connection string name called '" + connectionStringName + "'";
			}
		}

		//	if (String.IsNullOrEmpty(providerName))
		//		providerName="System.Data.SqlClient";

		return result;
	}

	string _connectionString="";
	string _providerName="";

	void InitConnectionString()
	{
		if (String.IsNullOrEmpty(_connectionString))
		{
			_connectionString = GetConnectionString(ref ConnectionStringName, out _providerName);

			if (_connectionString.Contains("|DataDirectory|"))
			{
				//have to replace it
				string dataFilePath = GetDataDirectory();
				_connectionString = _connectionString.Replace("|DataDirectory|", dataFilePath);
			}
		}
	}

	public string ConnectionString
	{
		get
		{
			InitConnectionString();
			return _connectionString;
		}
	}

	public string ProviderName
	{
		get
		{
			InitConnectionString();
			return _providerName;
		}
	}

	public EnvDTE.Project GetCurrentProject()
	{

		IServiceProvider _ServiceProvider = (IServiceProvider)Host;
		if (_ServiceProvider == null)
			throw new Exception("Host property returned unexpected value (null)");

		// EnvDTE.DTE dte = (EnvDTE.DTE)_ServiceProvider.GetService(typeof(EnvDTE.DTE));
		EnvDTE.DTE dte = (EnvDTE.DTE)_ServiceProvider.GetCOMService(typeof(EnvDTE.DTE));
		if (dte == null)
			throw new Exception("Unable to retrieve EnvDTE.DTE");

		Array activeSolutionProjects = (Array)dte.ActiveSolutionProjects;
		if (activeSolutionProjects == null)
			throw new Exception("DTE.ActiveSolutionProjects returned null");

		EnvDTE.Project dteProject = (EnvDTE.Project)activeSolutionProjects.GetValue(0);
		if (dteProject == null)
			throw new Exception("DTE.ActiveSolutionProjects[0] returned null");

		return dteProject;

	}

	private string GetProjectPath()
	{
		EnvDTE.Project project = GetCurrentProject();
		System.IO.FileInfo info = new System.IO.FileInfo(project.FullName);
		return info.Directory.FullName;
	}

	private string GetConfigPath()
	{
		if (ConfigPath != "")
			return Host.ResolvePath(ConfigPath);

		EnvDTE.Project project = GetCurrentProject();
		foreach (EnvDTE.ProjectItem item in project.ProjectItems)
		{
			// if it is the app.config file, then open it up
			if (item.Name.Equals("App.config", StringComparison.InvariantCultureIgnoreCase) || item.Name.Equals("Web.config", StringComparison.InvariantCultureIgnoreCase))
				return GetProjectPath() + "\\" + item.Name;
		}
		return String.Empty;
	}

	public string GetDataDirectory()
	{
		EnvDTE.Project project = GetCurrentProject();
		return System.IO.Path.GetDirectoryName(project.FileName) + "\\App_Data\\";
	}

	public string RemovePassword(string connectionString)
	{
		var rx = new Regex("Password=.*;", RegexOptions.Singleline | RegexOptions.IgnoreCase);
		return rx.Replace(connectionString, "Password=******;");
	}

	Tables LoadTables()
	{
		InitConnectionString();

		DbProviderFactory _factory;
		try
		{
			_factory = DbProviderFactories.GetFactory(ProviderName);
		}
		catch (Exception x)
		{
			var error = x.Message.Replace("\r\n", "\n").Replace("\n", " ");
			WriteLine("");
			WriteLine("// -----------------------------------------------------------------------------------------");
			WriteLine($"// Failed to load provider `{ProviderName}` - {error}");
			WriteLine("// -----------------------------------------------------------------------------------------");
			WriteLine("");
			this.Error($"Failed to load provider `{ProviderName}` - {error}");
			throw;
		}

		try
		{
			using (var conn = _factory.CreateConnection())
			{
				conn.ConnectionString = ConnectionString;
				conn.Open();

				SchemaReader reader = null;

				// Assume SQL Server
				reader = new SqlServerSchemaReader(
					this.ClassPrefix,
					this.ClassSuffix,
					this.InvalidPropertyNamePrefix,
					this.IncludeRelationships,
					this.MaxTextLine);

				reader.outer = this;
				var discoveredTables = reader.ReadSchema(conn, _factory);

				ConfigureTableMappings(discoveredTables);

				// Remove unrequired tables/views
				// remember that tbl.Ignore can be set by the developer with either a true/false value
				var filteredTables = discoveredTables
					.Where(tbl => tbl.Ignore == null || !tbl.Ignore.Value)
					.Where(tblOrView => tblOrView.Ignore == false || this.IncludeViews || !tblOrView.IsView)
					.Where(tbl => tbl.Ignore == false || string.IsNullOrEmpty(this.SchemaName) || string.Equals(this.SchemaName, tbl.Schema, StringComparison.InvariantCultureIgnoreCase))
					.Where(tbl =>
					{
						if (tbl.Ignore == false || ExcludeTablePrefixes == null || ExcludeTablePrefixes.Length == 0)
						{
							return true;
						}

						return !ExcludeTablePrefixes.Any(excludedTablePrefix => tbl.Name.StartsWith(excludedTablePrefix) || $"{tbl.Schema}.{tbl.Name}".ToString().StartsWith(excludedTablePrefix, StringComparison.InvariantCultureIgnoreCase));
					})
					.ToArray();
				conn.Close();

				return new Tables(filteredTables);
			}
		}
		catch (Exception x)
		{
			var error = x.Message.Replace("\r\n", "\n").Replace("\n", " ");
			WriteLine("");
			WriteLine("// -----------------------------------------------------------------------------------------");
			WriteLine($"// Failed to read database schema - {error}");
			WriteLine("// -----------------------------------------------------------------------------------------");
			WriteLine("");
			Error($"Failed to read database schema - {error}");
			throw;
		}
	}

	public abstract class SchemaReader
	{
		public abstract Tables ReadSchema(DbConnection connection, DbProviderFactory factory);

		public GeneratedTextTransformation outer;

		public void WriteLine(string o)
		{
			outer.WriteLine(o);
		}

	}

	public class SqlServerSchemaReader : SchemaReader
	{
		private readonly string _invalidPropertyNamePrefix;
		private readonly bool _includeRelationships;
		private readonly string _tablePrefix;
		private readonly string _tableSuffix;
		private readonly int _maxTextLine;
		private DbConnection _connection;
		private DbProviderFactory _factory;

		public SqlServerSchemaReader(
			string tablePrefix,
			string tableSuffix,
			string invalidPropertyNamePrefix, 
			bool includeRelationships,
			int maxTextLine)
		{
			_tablePrefix = tablePrefix;
			_tableSuffix = tableSuffix;
			_invalidPropertyNamePrefix = invalidPropertyNamePrefix;
			_includeRelationships = includeRelationships;
			_maxTextLine = maxTextLine;
		}

		public override Tables ReadSchema(
			DbConnection connection,
			DbProviderFactory factory)
		{
			var discoveredTables = new Tables();

			_connection = connection;
			_factory = factory;

			var cmd = _factory.CreateCommand();
			cmd.Connection = connection;
			cmd.CommandText = TABLE_SQL;

			//pull the tables in a reader
			using (cmd)
			{

				using (var rdr = cmd.ExecuteReader())
				{
					while (rdr.Read())
					{
						Table tbl = new Table(_invalidPropertyNamePrefix);
						tbl.Name = rdr["TABLE_NAME"].ToString();
						tbl.Schema = rdr["TABLE_SCHEMA"].ToString();
						tbl.IsView = string.Equals(rdr["TABLE_TYPE"].ToString(), "View", StringComparison.CurrentCultureIgnoreCase);
						tbl.ClassName = discoveredTables.GetNewValidClassName($"{_tablePrefix}{Singularize(tbl.Name)}{_tableSuffix}");
						tbl.Description = this.CleanDescription(rdr["TABLE_DESCRIPTION"] as string);

						discoveredTables.Add(tbl);
					}
				}
			}

			foreach (var tbl in discoveredTables)
			{
				DiscoverColumns(tbl);

				// Mark the primary keys
				var primaryKeys = GetPKs(tbl.Name).Select(pk => pk.ToLower().Trim()).ToArray();
				foreach (var pkColumn in tbl.Columns.Where(tblCol => primaryKeys.Any(pk => pk == tblCol.Name.ToLower().Trim())))
				{
					pkColumn.IsPK = true;
				}

				// Mark the columns with default values
				var defaultCols = GetColumnsWithDefaultValues(tbl.Name).Select(pk => pk.ToLower().Trim());
				foreach (var pkColumn in tbl.Columns.Where(tblCol => defaultCols.Any(pk => pk == tblCol.Name.ToLower().Trim())))
				{
					pkColumn.HasDefaultValue = true;
				}

				if (_includeRelationships)
				{
					try
					{
						tbl.ChildParentRelationships.AddRange(this.DiscoverChildParentRelationships(tbl.Name));
					}
					catch (Exception x)
					{
						var error = x.Message.Replace("\r\n", "\n").Replace("\n", " ");
						WriteLine("");
						WriteLine("// -----------------------------------------------------------------------------------------");
						WriteLine($"// Failed to get relationships for `{tbl.Name}` - {error}");
						WriteLine("// -----------------------------------------------------------------------------------------");
						WriteLine("");
						throw;
					}
				}

				this.EnsureCompositeKeysHaveOrderAssigned(tbl, primaryKeys);
			}

			// all the tables have been discovered, it's time to find some valid property names for our relationships
			foreach (var tbl in discoveredTables)
			{
				foreach (var childParentRelationship in tbl.ChildParentRelationships)
				{
					childParentRelationship.ReferencingNavigationPropertyName = tbl.GetNewValidPropertyName(Singularize(childParentRelationship.ReferencedTableName));

					// set up the order if we have to
					for (var refColumnIndex = 0; refColumnIndex < childParentRelationship.ReferencingColumnNames.Length; refColumnIndex++)
					{
						var referencingColumn = tbl[childParentRelationship.ReferencingColumnNames[refColumnIndex]];
						var referencedColumn = discoveredTables[childParentRelationship.ReferencedTableName][childParentRelationship.ReferencedColumnNames[refColumnIndex]];
						if (referencingColumn.Order == null)
						{
							referencingColumn.Order = referencedColumn.Order;
						}
					}

					// for each child-parent rel, we're gonna have a parent-child relationship
					var refTbl = discoveredTables.GetTable(childParentRelationship.ReferencedTableName);
					var parentChildRelationship = new Relationship()
						{
							RelationshipName = childParentRelationship.RelationshipName,
							ReferencedTableName = tbl.Name,
							ReferencingColumnNames = childParentRelationship.ReferencedColumnNames,
							ReferencedColumnNames = childParentRelationship.ReferencingColumnNames,
							ReferencingNavigationPropertyName = refTbl.GetNewValidPropertyName(Pluralize(tbl.Name)),
							ReferencingNavigationPropertyIsCollection = true
						};
					refTbl.ParentChildRelationships.Add(parentChildRelationship);

				}
			}

			return discoveredTables;
		}

		private void EnsureCompositeKeysHaveOrderAssigned(Table tbl, string[] columnNames)
		{
			if (columnNames.Length < 2)
			{
				return;
			}

			var currentColumnOrder = tbl.Columns.Max(col => col.Order ?? 0);
			foreach (var columnName in columnNames)
			{
				var column = tbl.GetColumn(columnName);
				if (column.Order == null)
				{
					column.Order = ++currentColumnOrder;
				}
			}
		}

		private string[] CleanDescription(string description)
		{
			if (string.IsNullOrWhiteSpace(description))
			{
				return new string[0];
			}

			var cleanDescriptionTextLines = new List<string>();
			var rxCleanup = new Regex(@"[\s]+");
			var cleanedDescription = rxCleanup.Replace(description, " ").Trim();
			while (cleanedDescription.Length > 0)
			{
				if (cleanedDescription.Length <= _maxTextLine)
				{
					cleanDescriptionTextLines.Add(cleanedDescription);
					cleanedDescription = string.Empty;
				}
				else
				{
					// find a split after max text line
					var breakTextLineIndex = cleanedDescription.IndexOf(' ', _maxTextLine);
					if (breakTextLineIndex < 0)
					{
						cleanDescriptionTextLines.Add(cleanedDescription);
						cleanedDescription = string.Empty;
					}
					else
					{
						cleanDescriptionTextLines.Add(cleanedDescription.Substring(0, breakTextLineIndex));
						cleanedDescription = cleanedDescription.Substring(breakTextLineIndex + 1);
					}
				}
			}
			return cleanDescriptionTextLines.ToArray();
		}

		void DiscoverColumns(Table tbl)
		{
			using (var cmd = _factory.CreateCommand())
			{
				cmd.Connection = _connection;
				cmd.CommandText = COLUMN_SQL;

				var p = cmd.CreateParameter();
				p.ParameterName = "@tableName";
				p.Value = tbl.Name;
				cmd.Parameters.Add(p);

				p = cmd.CreateParameter();
				p.ParameterName = "@schemaName";
				p.Value = tbl.Schema;
				cmd.Parameters.Add(p);

				using (IDataReader rdr = cmd.ExecuteReader())
				{
					while (rdr.Read())
					{
						Column col = new Column();
						col.Name = rdr["ColumnName"].ToString();
						col.IsComputed = ((int)rdr["IsComputed"]) == 1;
						col.PropertyName = tbl.GetNewValidPropertyName(col.Name);
						col.PropertyType = GetPropertyType(rdr["DataType"].ToString());
						col.IsNullable = rdr["IsNullable"].ToString() == "YES";
						col.IsAutoIncrement = ((int)rdr["IsIdentity"]) == 1;
						col.IsGeneratedUniqueIdentifier = rdr["DefaultSetting"].ToString().ToLower().Trim(' ', '(', ')') == "newid";
						col.Description = this.CleanDescription(rdr["Description"] as string);

						tbl.Columns.Add(col);
					}
				}
			}
		}

		Relationship[] DiscoverChildParentRelationships(string tableName)
		{
			using (var cmd = _factory.CreateCommand())
			{
				cmd.Connection = _connection;
				cmd.CommandText = CHILD_PARENT_REL_SQL;

				var p = cmd.CreateParameter();
				p.ParameterName = "@tableName";
				p.Value = tableName;
				cmd.Parameters.Add(p);

				var childParentRelationships = new List<Relationship>();

				// the raw sql will come back with independent referencing col -> referenced col 
				using (IDataReader rdr = cmd.ExecuteReader())
				{
					while (rdr.Read())
					{
						var relationship = new Relationship()
							{
								RelationshipName = rdr["FK"].ToString(),
								ReferencedTableName = rdr["Referenced_tbl"].ToString(),
								ReferencingColumnNames = new[]{ rdr["Referencing_col"].ToString() },
								ReferencedColumnNames = new[]{ rdr["Referenced_col"].ToString() }
							};

						childParentRelationships.Add(relationship);
					}
				}

				// when composite keys are involved, the returned rows will have the same name for a relationship
				return childParentRelationships.GroupBy(rel => rel.RelationshipName)
				                               .Select(relGroup => new Relationship()
					                               {
						                               RelationshipName = relGroup.Key,
						                               ReferencedTableName = relGroup.Select(rel => rel.ReferencedTableName).Distinct().Single(),
													   ReferencingColumnNames = relGroup.SelectMany(rel => rel.ReferencingColumnNames).ToArray(),
													   ReferencedColumnNames = relGroup.SelectMany(rel => rel.ReferencedColumnNames).ToArray()
					                               })
				                               .ToArray();
			}
		}

		List<string> GetPKs(string table)
		{

			string sql = @"SELECT c.name AS ColumnName
                FROM sys.indexes AS i 
                INNER JOIN sys.index_columns AS ic ON i.object_id = ic.object_id AND i.index_id = ic.index_id 
                INNER JOIN sys.objects AS o ON i.object_id = o.object_id 
                LEFT OUTER JOIN sys.columns AS c ON ic.object_id = c.object_id AND c.column_id = ic.column_id
                WHERE (i.type = 1) AND (o.name = @tableName)";

			var pks = new List<string>();

			using (var cmd = _factory.CreateCommand())
			{
				cmd.Connection = _connection;
				cmd.CommandText = sql;

				var p = cmd.CreateParameter();
				p.ParameterName = "@tableName";
				p.Value = table;
				cmd.Parameters.Add(p);

				using (IDataReader rdr = cmd.ExecuteReader())
				{
					while (rdr.Read())
					{
						pks.Add(rdr["ColumnName"].ToString());
					}
				}
			}

			return pks;
		}

		List<string> GetColumnsWithDefaultValues(string table)
		{

			string sql = @"SELECT d.ColumnName FROM
						(SELECT c.name as ColumnName, object_definition(c.default_object_id) AS DefaultDefinition
						FROM   sys.columns as c
						INNER JOIN sys.objects as o ON o.object_id = c.object_id
						WHERE o.name=@tableName) as d
					WHERE d.DefaultDefinition IS NOT NULL";

			var defaultCols = new List<string>();

			using (var cmd = _factory.CreateCommand())
			{
				cmd.Connection = _connection;
				cmd.CommandText = sql;

				var p = cmd.CreateParameter();
				p.ParameterName = "@tableName";
				p.Value = table;
				cmd.Parameters.Add(p);

				using (IDataReader rdr = cmd.ExecuteReader())
				{
					while (rdr.Read())
					{
						defaultCols.Add(rdr["ColumnName"].ToString());
					}
				}
			}

			return defaultCols;
		}


		static string GetPropertyType(string sqlType)
		{
			switch (sqlType)
			{
				case "bigint":
					return "long";
				case "smallint":
					return "short";
				case "int":
					return "int";
				case "uniqueidentifier":
					return "Guid";
				case "smalldatetime":
				case "datetime":
				case "datetime2":
				case "date":
				case "time":
					return "DateTime";
				case "float":
					return "double";
				case "real":
					return "float";
				case "numeric":
				case "smallmoney":
				case "decimal":
				case "money":
					return "decimal";
				case "tinyint":
					return "byte";
				case "bit":
					return "bool";
				case "image":
				case "binary":
				case "varbinary":
				case "timestamp":
					return "byte[]";
				case "geography":
					return "Microsoft.SqlServer.Types.SqlGeography";
				case "geometry":
					return "Microsoft.SqlServer.Types.SqlGeometry";
				case "datetimeoffset":
					return "DateTimeOffset";
				default:
					return "string";
			}
		}

		const string TABLE_SQL = @"SELECT TABLES.*,
		DescriptionExProps.value as TABLE_DESCRIPTION
		FROM  INFORMATION_SCHEMA.TABLES
		OUTER APPLY fn_listextendedproperty('MS_Description', 'schema', TABLES.TABLE_SCHEMA, 'table', TABLES.TABLE_NAME, null, null) As DescriptionExProps
		WHERE TABLE_TYPE='BASE TABLE' OR TABLE_TYPE='VIEW'
		ORDER BY TABLE_SCHEMA, TABLE_NAME
		";

		const string COLUMN_SQL = @"SELECT 
			TABLE_CATALOG AS [Database],
			TABLE_SCHEMA AS Owner, 
			TABLE_NAME AS TableName, 
			COLUMN_NAME AS ColumnName, 
			ORDINAL_POSITION AS OrdinalPosition, 
			COLUMN_DEFAULT AS DefaultSetting, 
			IS_NULLABLE AS IsNullable, DATA_TYPE AS DataType, 
			CHARACTER_MAXIMUM_LENGTH AS MaxLength, 
			DATETIME_PRECISION AS DatePrecision,
			COLUMNPROPERTY(object_id('[' + TABLE_SCHEMA + '].[' + TABLE_NAME + ']'), COLUMN_NAME, 'IsIdentity') AS IsIdentity,
			COLUMNPROPERTY(object_id('[' + TABLE_SCHEMA + '].[' + TABLE_NAME + ']'), COLUMN_NAME, 'IsComputed') as IsComputed,
			DescriptionExProps.value as Description
		FROM  INFORMATION_SCHEMA.COLUMNS
		OUTER APPLY fn_listextendedproperty('MS_Description', 'schema', @schemaName, 'table', @tableName, 'column', COLUMN_NAME) As DescriptionExProps
		WHERE TABLE_NAME=@tableName AND TABLE_SCHEMA=@schemaName
		ORDER BY OrdinalPosition ASC";

		const string CHILD_PARENT_REL_SQL = @"SELECT 
			FK = OBJECT_NAME(pt.constraint_object_id),
			Referenced_tbl = OBJECT_NAME(pt.referenced_object_id),
			Referencing_col = pc.name, 
			Referenced_col = rc.name
		FROM sys.foreign_key_columns AS pt
		INNER JOIN sys.columns AS pc
		ON pt.parent_object_id = pc.[object_id]
		AND pt.parent_column_id = pc.column_id
		INNER JOIN sys.columns AS rc
		ON pt.referenced_column_id = rc.column_id
		AND pt.referenced_object_id = rc.[object_id]
		WHERE pt.parent_object_id = OBJECT_ID(@tableName);";
	}

#>
